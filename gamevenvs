import os
import random
from datetime import datetime

class TicTacToe:
    def __init__(self, size=3):
        self.size = size
        self.board = [['.' for _ in range(size)] for _ in range(size)]
        self.current_player = None
        self.stats_dir = "game_stats"
        self.create_stats_directory()
        
    def create_stats_directory(self):
        if not os.path.exists(self.stats_dir):
            os.makedirs(self.stats_dir)
    
    def save_game_result(self, winner):
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"{self.stats_dir}/game_{timestamp}.txt"
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(f"Размер поля: {self.size}x{self.size}\n")
            f.write(f"Первый игрок: {self.current_player}\n")
            f.write("Финальное состояние поля:\n")
            f.write(self.get_board_string())
            f.write(f"\nРезультат: {winner}\n")
    
    def choose_first_player_randomly(self):
        self.current_player = random.choice(['X', 'O'])
        print(f"Первый ход делает игрок: {self.current_player}")
    
    def get_board_string(self):
        board_str = "   " + " ".join(str(i+1) for i in range(self.size)) + "\n"
        for i in range(self.size):
            board_str += f"{i+1}  " + " ".join(self.board[i]) + "\n"
        return board_str
    
    def print_board(self):
        print(self.get_board_string())
    
    def is_valid_move(self, row, col):
        return (0 <= row < self.size and 
                0 <= col < self.size and 
                self.board[row][col] == '.')
    
    def make_move(self, row, col):
        if self.is_valid_move(row, col):
            self.board[row][col] = self.current_player
            return True
        return False
    
    def switch_player(self):
        self.current_player = 'O' if self.current_player == 'X' else 'X'
    
    def check_winner(self):
        for i in range(self.size):
            if all(self.board[i][j] == self.current_player for j in range(self.size)):
                return True
        
        for j in range(self.size):
            if all(self.board[i][j] == self.current_player for i in range(self.size)):
                return True
        
        if all(self.board[i][i] == self.current_player for i in range(self.size)):
            return True
        
        if all(self.board[i][self.size-1-i] == self.current_player for i in range(self.size)):
            return True
        
        return False
    
    def is_board_full(self):
        for i in range(self.size):
            for j in range(self.size):
                if self.board[i][j] == '.':
                    return False
        return True
    
    def reset_game(self, new_size=None):
        if new_size:
            self.size = new_size
        self.board = [['.' for _ in range(self.size)] for _ in range(self.size)]
        self.choose_first_player_randomly()
    
    def get_valid_size(self):
        while True:
            try:
                size = int(input("Enter the size of the board (3-9): "))
                if 3 <= size <= 9:
                    return size
                else:
                    print("Invalid size, please enter again")
            except ValueError:
                print("Please enter a valid number")
    
    def get_player_move(self):
        while True:
            try:
                move = input(f"{self.current_player}'s turn. Enter row and column (e.g. 1 2): ")
                row, col = map(int, move.split())
                row -= 1
                col -= 1
                
                if self.is_valid_move(row, col):
                    return row, col
                else:
                    print("Invalid move! Cell is occupied or out of bounds. Try again.")
            except (ValueError, IndexError):
                print("Invalid input! Please enter two numbers separated by space (e.g. '1 2').")
    
    def play_game(self):
        print(" Крестики-нолики ")
        
        size = self.get_valid_size()
        self.reset_game(size)
        
        while True:
            self.print_board()
            
            row, col = self.get_player_move()
            self.make_move(row, col)
            
            if self.check_winner():
                self.print_board()
                print(f"{self.current_player} wins!")
                self.save_game_result(f"Победитель: {self.current_player}")
                break
            
            if self.is_board_full():
                self.print_board()
                print("It's a tie!")
                self.save_game_result("Ничья")
                break
            
            self.switch_player()
        
        self.offer_replay()
    
    def offer_replay(self):
        while True:
            choice = input("\nХотите сыграть еще раз? (y/n): ").lower().strip()
            if choice in ['y', 'yes', 'д', 'да']:
                print("\n" + "="*30)
                self.play_game()
                break
            elif choice in ['n', 'no', 'н', 'нет']:
                print("Спасибо за игру! До свидания!")
                break
            else:
                print("Пожалуйста, введите 'y' или 'n'")

def main():
    game = TicTacToe()
    game.play_game()

if __name__ == "__main__":
    main()
